<!doctype html>
<meta charset="utf-8" />
<title>Coco notes -- How to hide data in dithering patterns</title>
<style>
	body { max-width:90ex; }
	pre { background:lightgray; width:80ch; }
	table, td { border:1px solid black; border-collapse:collapse; }
	table td { padding:7px; border-spacing:0px; }
	.thm em i { font-style: normal;}
</style>
<script type="text/x-mathjax-config">
	MathJax.Hub.Config({
		tex2jax: {
			inlineMath: [ ['$','$'], ['\\(','\\)'] ],
			processEscapes: true
		}
	});
</script>
<script async src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS_CHTML-full">
</script>

<!--
	This file is a literate program.
	The experiments are run by applying the following filter:

		grep ^%SCRIPT | sed 's/&amp;/\&/g' | cut -c9- | sh
-->


<h1>How to hide data in dithering patterns</h1>

<p>
In this note we describe a simple method for encoding arbitrary data in
dithered binary images.
The density is about 0.25 bits per pixel in non-saturated
regions, and zero bits in saturated regions.
Unless the encoded data has some pattern, the encoding is not visible.

<h2>1. Description of the method</h2>

<p>
Sometimes you want to represent gray-scale data by black and white dots.  The
naive technique is to throw a random binary pixel with the probability of
being white given by the gray level.  This is called random dithering, and is
trivial to implement, but it loses a lot of resolution.  A better technique
is <i>error diffusion</i>, where you traverse the pixels in order and select
the black or white value that minimizes the ongoing average error.  Notice
that this depends on the order of traversal.  For uniform regions it tends to
produce visible patterns, and this can be avoided by traversing the pixels in
a more or less random way (for example, a hilbert curve is often used).

<table>
<tr><td>

	<img src="i/psimone.png" alt="image"> <td>
	<a href="z-psimone-random.png"><img src="psimone-random.png" alt="image"></a> <td>
	<a href="z-psimone-errdif.png"><img src="psimone-errdif.png" alt="image"></a> <tr><td>
	gray-scale <td>
	random <td>
	error diffusion
</table>
<!--
%SCRIPT plambda psimone.png 'randu 255 * > 255 *' -o psimone-random.png
%SCRIPT dither psimone.png psimone-errdif.png
-->

<p>
Since there is a lot of choice when dithering an image, we can encode a lot
of information in these choices.  Assuming that we will be able to recover
the binary image exactly, the simplest way to encode the data is to have a
<b>table of patterns</b> such as this:

<table>
<tr><td>

	pattern <td>
	<img src="pat_0.png" alt="image"> <td>
	<img src="pat_1.png" alt="image"> <td>
	<img src="pat_2.png" alt="image"> <td>
	<img src="pat_3.png" alt="image"> <td>
	<img src="pat_4.png" alt="image"> <td>
	<img src="pat_5.png" alt="image"> <td>
	<img src="pat_6.png" alt="image"> <td>
	<img src="pat_7.png" alt="image"> <td>
	<img src="pat_8.png" alt="image"> <td>
	<img src="pat_9.png" alt="image"> <td>
	<img src="pat_10.png" alt="image"> <td>
	<img src="pat_11.png" alt="image"> <td>
	<img src="pat_12.png" alt="image"> <td>
	<img src="pat_13.png" alt="image"> <td>
	<img src="pat_14.png" alt="image"> <td>
	<img src="pat_15.png" alt="image"> <tr><td>
	index <td>
	0 <td> 1 <td> 2 <td> 3 <td> 4 <td> 5 <td> 6 <td> 7 <td> 8 <td> 9 <td> 10 <td> 11 <td> 12 <td> 13 <td> 14 <td> 15 <tr><td>
	intensity <td>
	0 <td> 1 <td> 1 <td> 2 <td> 1 <td> 2 <td> 2 <td> 3 <td> 1 <td> 2 <td>  2 <td>  3 <td>  2 <td>  3 <td>  3 <td>  4 <tr><td>
	group <td>
	$-$ <td> $a_0$ <td> $a_1$ <td> $-$ <td> $b_0$ <td> $c_0$ <td> $c_1$ <td> $d_0$ <td>
	$b_1$ <td> $e_0$ <td> $e_1$ <td> $d_1$ <td> $-$ <td> $f_0$ <td> $f_1$ <td> $-$
</table>

<!--
%SCRIPT printf 'P2\n2 2\n1\n0 0 0 0\n'|plambda '200 *'|ntiply 16 - pat_0.png
%SCRIPT printf 'P2\n2 2\n1\n0 0 0 1\n'|plambda '200 *'|ntiply 16 - pat_1.png
%SCRIPT printf 'P2\n2 2\n1\n0 0 1 0\n'|plambda '200 *'|ntiply 16 - pat_2.png
%SCRIPT printf 'P2\n2 2\n1\n0 0 1 1\n'|plambda '200 *'|ntiply 16 - pat_3.png
%SCRIPT printf 'P2\n2 2\n1\n0 1 0 0\n'|plambda '200 *'|ntiply 16 - pat_4.png
%SCRIPT printf 'P2\n2 2\n1\n0 1 0 1\n'|plambda '200 *'|ntiply 16 - pat_5.png
%SCRIPT printf 'P2\n2 2\n1\n0 1 1 0\n'|plambda '200 *'|ntiply 16 - pat_6.png
%SCRIPT printf 'P2\n2 2\n1\n0 1 1 1\n'|plambda '200 *'|ntiply 16 - pat_7.png
%SCRIPT printf 'P2\n2 2\n1\n1 0 0 0\n'|plambda '200 *'|ntiply 16 - pat_8.png
%SCRIPT printf 'P2\n2 2\n1\n1 0 0 1\n'|plambda '200 *'|ntiply 16 - pat_9.png
%SCRIPT printf 'P2\n2 2\n1\n1 0 1 0\n'|plambda '200 *'|ntiply 16 - pat_10.png
%SCRIPT printf 'P2\n2 2\n1\n1 0 1 1\n'|plambda '200 *'|ntiply 16 - pat_11.png
%SCRIPT printf 'P2\n2 2\n1\n0 0 0 0\n'|plambda '200 *'|ntiply 16 - pat_0.png
%SCRIPT printf 'P2\n2 2\n1\n1 1 0 0\n'|plambda '200 *'|ntiply 16 - pat_12.png
%SCRIPT printf 'P2\n2 2\n1\n1 1 0 1\n'|plambda '200 *'|ntiply 16 - pat_13.png
%SCRIPT printf 'P2\n2 2\n1\n1 1 1 0\n'|plambda '200 *'|ntiply 16 - pat_14.png
%SCRIPT printf 'P2\n2 2\n1\n1 1 1 1\n'|plambda '200 *'|ntiply 16 - pat_15.png
-->

<p>
A binary image is divided in $2\times2$ cells, and each cell is identified
with one of the patterns of the table (cells marked with $-$ are not used).
Then the pairs of patterns $x_0$ and $x_1$, which have always the same
intensity, are considered equivalent and each of them is used to encode a bit
of information, losing the original pattern.

<p>
The <i>potential bit content</i> of a binary image is defined as the number
of $2\times2$ cells that match a valid pattern in this table.
Notice that saturated regions (either black or white) can not encode any
information, so that it is better to avoid them as much as possible.
They can be avoided, for example, by applying a retinex-like transform in the
input image, before dithering.

<table>
<tr><td>

	<td>
	original <td>
	$\gamma=0.5$ <td>
	$\gamma=2$ <td>
	retinex <tr><td>
	
	gray <td>
	<img src="i/psimone.png" alt="image"> <td>
	<img src="psimone-gam.png" alt="image"> <td>
	<img src="psimone-ugam.png" alt="image"> <td>
	<img src="psimone-ret.png" alt="image"> <tr><td>
	binary <td>
	<a href="z-psimone-errdif.png"><img src="psimone-errdif.png" alt="image"></a>  <td>
	<a href="z-psimone-gamdit.png"><img src="psimone-gamdit.png" alt="image"></a>  <td>
	<a href="z-psimone-ugamdit.png"><img src="psimone-ugamdit.png" alt="image"></a> <td>
	<a href="z-psimone-retdit.png"><img src="psimone-retdit.png" alt="image"></a>  <tr><td>
	bytes <td>
	987.25
 <td>
	232
 <td>
	343.5
 <td>
	881.875

</table>
<!--
%SCRIPT qeasy 0 160 psimone.png psimone-sat.png
%SCRIPT plambda psimone.png '160 / 2 ^ 255 *' -o psimone-gam.png
%SCRIPT plambda psimone.png '160 / 0.5 ^ 255 *' -o psimone-ugam.png
%SCRIPT plambda psimone.png 'x,l -1 *'|blur z 0.2|qauto - psimone-ret.png
%SCRIPT dither psimone-sat.png psimone-satdit.png
%SCRIPT dither psimone-gam.png psimone-gamdit.png
%SCRIPT dither psimone-ugam.png psimone-ugamdit.png
%SCRIPT dither psimone-ret.png psimone-retdit.png
%SCRIPT mdither count psimone-errdif.png  | cut -d' ' -f 3 > berrdit.txt
%SCRIPT mdither count psimone-gamdit.png  | cut -d' ' -f 3 > bgamdit.txt
%SCRIPT mdither count psimone-ugamdit.png | cut -d' ' -f 3 > bugamdit.txt
%SCRIPT mdither count psimone-retdit.png  | cut -d' ' -f 3 > bretdit.txt
-->

<p>
The following figure shows the effect of the actual encoding.  We encode a
stream of random bits, and a stream of zero bits.  Notice that the stream of
zeros introduces a visible pattern in the image.  To avoid these patterns,
the data to be encoded must have a uniform distribution (for example, by
compressing it).

<table>
<tr><td>

	<a href="z-psimone-retdit.png"><img src="psimone-retdit.png" alt="image"></a><td>
	<a href="z-psimone-retditR.png"><img src="psimone-retditR.png" alt="image"></a><td>
	<a href="z-psimone-retditZ.png"><img src="psimone-retditZ.png" alt="image"></a><tr><td>
	input <td> random <td> zeros
</table>
<!--
%SCRIPT mdither encode psimone-retdit.png psimone-retditR.png < /dev/urandom
%SCRIPT mdither encode psimone-retdit.png psimone-retditZ.png < /dev/zero
%SCRIPT for i in psimone*png; do ntiply 3 $i z-$i ; done
-->
(click on each image to see it bigger)

<h2>2. Implementation</h2>

<p>
A C implementation of this technique is available in
<a href="https://github.com/mnhrdt/imscript/blob/master/src/mdither.c">imscript</a>,
as the program <code>mdither</code>.  All the experiments described in this page
have been created automatically by extracting the comments in the source (see
the HTML source to view them).

<h3>2.1. Floyd-Sternberg dithering</h3>

<p>
To binarize a gray-scale image by Floyd-Sternberg dithering you can use the
program ``<code>dither</code>''

<pre>
dither weil.png weil-dit.png
</pre>
<table>
<tr><td>

	<img src="i/weil.png" alt="image"> <td>
	<img src="weil-dit.png" alt="image"> <tr><td>
	<code>weil.png</code> <td>
	<code>weil-dit.png</code>
</table>

<h3>2.2. Counting the carrying capacity of an image</h3>

<p>
The program ``<code>mdither count</code>'' prints the number of bits, bytes, kilobites
and megabytes that can be potentially encoded on a given image

<pre>
mdither count weil-dit.png &gt; weil-capacity.txt
</pre>
<pre>
15218 bits 1902.25 bytes 1.85767 k 0.00181413 M
</pre>

<h3>2.3. Encoding bits into a carrier image</h3>

<p>
The program ``<code>mdither encode</code>'' encodes a stream of bytes into a
carrier image.  In the following example we encode a random stream of bits
and a stream of zeros in the same carrier image.

<pre>
mdither encode weil-dit.png weil-random.png &lt; /dev/urandom
mdither encode weil-dit.png weil-zeros.png  &lt; /dev/zero
</pre>
<table>
<tr><td>

	<img src="weil-random.png" alt="image"> <td>
	<img src="weil-zeros.png" alt="image"> <tr><td>
	<code>weil-random.png</code> <td>
	<code>weil-zeros.png</code>
</table>

<h3>2.4. Decoding bits from an image</h3>

<p>
And this information can be extracted by the program ``<code>mdither decode</code>'':
<pre>
mdither decode weil-random.png | hexdump -vn 128 &gt; weil-random.txt
mdither decode weil-zeros.png  | hexdump -vn 128 &gt; weil-zeros.txt
</pre>

<p>
Contents of file <code>weil-random.txt</code>:
<pre>
0000000 50af e554 6422 abe3 36e2 fe6d 975b 08f4
0000010 8bbf 3a8d 0942 169f 9f8c eeaa 95e6 ed52
0000020 8380 f072 da5f be96 0148 6507 b5e0 f4b1
0000030 b800 c305 e2f0 4246 c31e cd6b 83ed 7376
0000040 1ef4 0a11 8153 cce2 9f23 7103 5a32 f1a6
0000050 0a26 9e9b 309e 53ec fc37 c0f0 bb9b e6b1
0000060 b64f 5687 efce 4ff5 db2f 7b0b 9e3e db44
0000070 05bd f78e 4160 a69c 095d c39f 6902 8c0c
0000080
</pre>

<p>
Contents of file <code>weil-zeros.txt</code>:
<pre>
0000000 0000 0000 0000 0000 0000 0000 0000 0000
0000010 0000 0000 0000 0000 0000 0000 0000 0000
0000020 0000 0000 0000 0000 0000 0000 0000 0000
0000030 0000 0000 0000 0000 0000 0000 0000 0000
0000040 0000 0000 0000 0000 0000 0000 0000 0000
0000050 0000 0000 0000 0000 0000 0000 0000 0000
0000060 0000 0000 0000 0000 0000 0000 0000 0000
0000070 0000 0000 0000 0000 0000 0000 0000 0000
0000080
</pre>

<h2>3. Examples</h2>

<p>
Here we show examples of random bits encoded into the example images of this
project, using different resolutions.
En each case, we show the binary image along the number of bytes of encoded
information it contains.

<p>
In all cases, the images were pre-processed by a linear retinex filter and a
contrast change that forces the background to be a light-gray (in order to
maximize the available space for encoding the information).

<!--
%SCRIPT qauto j/i1.png | plambda 'x,l -1 *'|blur -z z 0.1|qauto - photo1.png
%SCRIPT qauto j/i2.png | plambda 'x,l -1 *'|blur -z z 0.1|qauto - photo2.png
%SCRIPT qeasy 10 120 j/i3.png | plambda 'x,l -1 *'|blur -z z 0.1|qauto - photo3.png
%SCRIPT qeasy 30 70 j/i4.png | plambda 'x,l -1 *'|blur -z z 0.1|qauto - photo4.png
%SCRIPT qeasy 40 170 j/i5.png | plambda 'x,l -1 *'|blur -z z 0.1|qauto - photo5.png
-->

<!--
%SCRIPT for i in 1 2 3 4 5; do for j in 1 2 3 4 5 6 7; do downsa v $j photo$i.png |qauto| dither - diphoto-${i}-${j}.png ; done ; done
-->

<!--
%SCRIPT for i in diphoto*png; do mdither count $i | cut -d' ' -f3 > bytes-$i ; done
%SCRIPT for i in diphoto*png; do mdither encode $i E$i < /dev/urandom ; done
-->

<h3>3.5. Test image ``photo 1''</h3>

<table>
<tr><td>

	<img src="Ediphoto-1-1.png" alt="image"> <td>
	<img src="Ediphoto-1-2.png" alt="image"> <td>
	<img src="Ediphoto-1-3.png" alt="image"> <td>
	<img src="Ediphoto-1-4.png" alt="image"> <td>
	<img src="Ediphoto-1-5.png" alt="image"> <td>
	<img src="Ediphoto-1-6.png" alt="image"> <td>
	<img src="Ediphoto-1-7.png" alt="image"> <tr><td>
	7214.5
 <td>
	1694.38
 <td>
	742.25
 <td>
	411.625
 <td>
	252.5
 <td>
	170
 <td>
	124.5

</table>

<h3>3.6. Test image ``photo 2''</h3>

<table>
<tr><td>

	<img src="Ediphoto-2-1.png" alt="image"> <td>
	<img src="Ediphoto-2-2.png" alt="image"> <td>
	<img src="Ediphoto-2-3.png" alt="image"> <td>
	<img src="Ediphoto-2-4.png" alt="image"> <td>
	<img src="Ediphoto-2-5.png" alt="image"> <td>
	<img src="Ediphoto-2-6.png" alt="image"> <td>
	<img src="Ediphoto-2-7.png" alt="image"> <tr><td>
	8466.88
 <td>
	1903.38
 <td>
	815.75
 <td>
	452.875
 <td>
	282
 <td>
	194.375
 <td>
	142.25

</table>

<h3>3.7. Test image ``photo 3''</h3>

<table>
<tr><td>

	<img src="Ediphoto-3-1.png" alt="image"> <td>
	<img src="Ediphoto-3-2.png" alt="image"> <td>
	<img src="Ediphoto-3-3.png" alt="image"> <td>
	<img src="Ediphoto-3-4.png" alt="image"> <td>
	<img src="Ediphoto-3-5.png" alt="image"> <td>
	<img src="Ediphoto-3-6.png" alt="image"> <td>
	<img src="Ediphoto-3-7.png" alt="image"> <tr><td>
	7955.5
 <td>
	1794.75
 <td>
	749.125
 <td>
	413
 <td>
	257.25
 <td>
	175.625
 <td>
	127.75

</table>

<h3>3.8. Test image ``photo 4''</h3>

<table>
<tr><td>

	<img src="Ediphoto-4-1.png" alt="image"> <td>
	<img src="Ediphoto-4-2.png" alt="image"> <td>
	<img src="Ediphoto-4-3.png" alt="image"> <td>
	<img src="Ediphoto-4-4.png" alt="image"> <td>
	<img src="Ediphoto-4-5.png" alt="image"> <td>
	<img src="Ediphoto-4-6.png" alt="image"> <td>
	<img src="Ediphoto-4-7.png" alt="image"> <tr><td>
	8424.38
 <td>
	2004.38
 <td>
	854.875
 <td>
	474.75
 <td>
	298.25
 <td>
	203.625
 <td>
	147.125

</table>

<h3>3.9. Test image ``photo 5''</h3>

<table>
<tr><td>

	<img src="Ediphoto-5-1.png" alt="image"> <td>
	<img src="Ediphoto-5-2.png" alt="image"> <td>
	<img src="Ediphoto-5-3.png" alt="image"> <td>
	<img src="Ediphoto-5-4.png" alt="image"> <td>
	<img src="Ediphoto-5-5.png" alt="image"> <td>
	<img src="Ediphoto-5-6.png" alt="image"> <td>
	<img src="Ediphoto-5-7.png" alt="image"> <tr><td>
	8019.5
 <td>
	1849.62
 <td>
	803.375
 <td>
	453.875
 <td>
	284.75
 <td>
	194.625
 <td>
	142.375

</table>


<hr>


<!-- yes i know, wanna fight about it ? -->
<img src="http://boucantrin.ovh.hw.ipol.im:7743/white_pixel.png?a=How_to_hide_data_in_dithering_patterns" width="1" height="1" alt="">

