<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Image processing with graphs</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <style type="text/css">
  	body{max-width:90ex;}
  	pre{background:lightgray;width:80ch;}
  </style>
</head>
<body>
<header>
<h1 class="title">Image processing with graphs</h1>
</header>
<p>This is one of the best books in image processing:</p>
<p><img src="i/graphcover.png" alt="image" /></p>
<p>You should buy several copies, for yourself, your friends and your family; and ask your lab to buy several copies for the library. Or even better, since the editor (whose name I have trimmed from the cover image) is a notorious bully, instead of buying it, download a copy from libgen and send the money directly to the authors.</p>
<p>The book is a collection of independent self-contained chapters written by different authors, all of them famous people from the french school of image processing.</p>
<p>The only critique of this book that I can conceive is that the “practice” part of the title is not really fullfilled. There is not a single line of real computer code displayed in the book. But giving the codes for the hundreds of experiments of a 500 page book is probably too much to ask. The goal of this document is to provide such a code for a small part of the book.</p>
<p>My favourite chapters are 6 and 7:</p>
<p><span><strong>6. A short tour of mathematical morphology on edge and vertex weighted graphs</strong></span>, <span><em>Laurent Najman and Fernand Meyer</em></span></p>
<p><span><strong>7. Partial difference quations on graphs for local and nonlocal image processing</strong></span>, <span><em>Abrerrahim Elmoataz, Olivier Lézoray, Vinh-Thong Ta and Sébastien Bougleux</em></span>.</p>
<p>And these are the chapters whose implementation I detail below.</p>
<h2 id="the-basic-approach"><span class="header-section-number">1</span> The basic approach</h2>
<p>The book contains this kind of sentences:</p>
<blockquote>
<p>Let <span class="math inline">\(G=(V,E)\)</span> be a graph and <span class="math inline">\(\mathcal{H}(V)\)</span> be the Hilbert space of real-valued functions defined on the vertices of <span class="math inline">\(G\)</span>. The space <span class="math inline">\(\mathcal{H}(V)\)</span> is endowed with the usual inner product <span class="math inline">\(\left&lt;f,h\right&gt;_{\mathcal{H}(V)}=\sum_{v_i\in V}f(v_i)h(v_i)\)</span>, where <span class="math inline">\(f,h:V\to\mathbf{R}\)</span>. Similarly, let <span class="math inline">\(\mathcal{H}(E)\)</span> be the Hilbert space of real-valued functions defined on the edges of <span class="math inline">\(G\)</span>, <span class="math inline">\(\ldots\)</span>. Now, consider a linear operator between Hilbert spaces <span class="math inline">\(A:\mathcal{H}(V)\to\mathcal{E}(V)\)</span>...</p>
</blockquote>
<p>While these sentences are crystal clear and very appealing to an audience of mathematicians, I have found them to be intimidating when trying to evangelize people to read the book. Thus, I “translate” them into the following kind of language, which is <span class="math inline">\(100\%\)</span> equivalent:</p>
<blockquote>
<p>Consider a graph with <span class="math inline">\(n\)</span> vertices and <span class="math inline">\(m\)</span> edges. We will use vectors of length <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> to represent functions defined over the vertices or the edges, respectively. We will also use matrices of size <span class="math inline">\(m\times n\)</span> to represent linear maps between them <span class="math inline">\(A:\mathbf{R}^n\to\mathbf{R}^m\)</span>. In octave/matlab:</p>
<pre><code>n = 100;            # number of vertices in the graph
m = 200;            # number of edges in the graph
x = rand(n,1);      # define a random function over the vertices
A = rand(m,n);      # define a random linear map
y = A * x;          # obtain a function over the edges</code></pre>
</blockquote>
<p>This is easier to interpret thanks to the computer code. Of course, linear maps with random coefficients are silly. We will see more interesting examples below.</p>
<h2 id="matrices-of-a-graph"><span class="header-section-number">2</span> Matrices of a graph</h2>
<p>You would think that to work with graphs on a computer you need some sort of library for graphs. Nothing farther from the truth. What you really need is a library for doing <em>linear algebra</em>. In all the examples here we use octave, but you can translate it easily to python+numpy, which is slightly more verbose.</p>
<p>In what follows we reserve the letters <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> for the following meanings</p>
<p><span class="math inline">\(n\, =\ \,\)</span> number of vertices in the graph<br />
<span class="math inline">\(m =\ \,\)</span> number of edges in the graph</p>
<p>For the following graph, we have <span class="math inline">\(n=5\)</span> and <span class="math inline">\(m=6\)</span>:</p>
<p><img src="gggx.png" alt="image" /></p>
<p><span class="math display">\[Z = \begin{pmatrix}
1 &amp; 2 \\
1 &amp; 3 \\
2 &amp; 3 \\
3 &amp; 4 \\
3 &amp; 5 \\
4 &amp; 5
\end{pmatrix}_{\small 6\times 2}
A = \begin{pmatrix}
    0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\
    1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
    1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 \\
    0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\
    0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\
\end{pmatrix}_{\small 5\times 5}
B = \begin{pmatrix}
    -1&amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
    -1&amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp;-1 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp;-1 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp;-1 &amp; 0 &amp; 1 \\
    0 &amp; 0 &amp; 0 &amp;-1 &amp; 1 \\
\end{pmatrix}_{\small 6\times 5}\]</span></p>
<p>There are <span><strong>five</strong></span> basic matrices associated to a graph, for which we will always use the same letters:</p>
<p><span class="math inline">\(Z\ \,=\ \,\)</span> adjacency list, of size <span class="math inline">\(m\times 2\)</span>, list of vertex index pairs<br />
<span class="math inline">\(A\ \,=\ \,\)</span> adjacency matrix, of size <span class="math inline">\(n\times n\)</span>, logical matrix of joined vertices<br />
<span class="math inline">\(B\ \,=\ \,\)</span> incidence matrix, of size <span class="math inline">\(m\times n\)</span>, list of input/output vertices of each edge<br />
<span class="math inline">\(C\ \,=\ \,\)</span> centering matrix, of size <span class="math inline">\(m\times n\)</span>, defined as <span class="math inline">\(C=\frac{1}{2}|B|\)</span><br />
<span class="math inline">\(L\ \,=\ \,\)</span> Laplacian matrix, of size <span class="math inline">\(n\times n\)</span>, defined as <span class="math inline">\(L=-B&#39;B\)</span></p>
<p>It is very important to understand now the meaning of the matrices <span class="math inline">\(Z,A,B\)</span>. The matrix <span class="math inline">\(Z\)</span> is the easiest to type by hand in a computer, but it is not very useful for doing algebra with it. All the other matrices are fundamental linear operators over functions defined on the graph. Each of these fives matrices, alone, determines completely the graph (modulo the numbering of the edges, in the case of <span class="math inline">\(A\)</span> and <span class="math inline">\(L\)</span>).</p>
<p>The matrices <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span> and <span class="math inline">\(C\)</span> satisfy the identity: <span class="math inline">\(A=2C^TC-B^TB/2\)</span>. This allows to compute <span class="math inline">\(A\)</span> from <span class="math inline">\(B\)</span>. To recover <span class="math inline">\(B\)</span> from <span class="math inline">\(A\)</span> we must decide on an ordering for the edges.</p>
<p>The following octave functions allow to convert between each representation:</p>
<pre><code>function A = graph_adjacency_from_list(Z)
        n = max(Z(:));                        # number of vertices
        U = sparse(Z(:,1), Z(:,2), 1, n, n);  # directed graph
        A = U + U&#39;;                           # symmetrization
end</code></pre>
<pre><code>function B = graph_incidence_from_adjacency(A)
        [i,j] = find(triu(A));                 # find the (i,j) positions
        n = rows(A);                           # number of vertices
        m = rows(i);                           # total number of edges
        B1 = sparse(1:m, i, 1, m, n);          # matrix for destination vertices
        B2 = sparse(1:m, j, 1, m, n);          # matrix for source vertices
        B = B1 - B2;                           # signed incidence matrix
end</code></pre>
<pre><code>function Z = graph_list_from_adjacency(A)
        [i,j] = find(triu(A));
        Z = [i j];
end</code></pre>
<pre><code>function A = graph_adjacency_from_incidence(B)
        A = max(-B&#39;*B,0);            # equal to (abs(B&#39;*B) - B&#39;*B) / 2
end</code></pre>
<p>Typically, in the applications, you can often build <span class="math inline">\(B\)</span> directly so that you do not really need these functions. From <span class="math inline">\(B\)</span>, the other matrices are easily computed if needed by:</p>
<pre><code>L = -B&#39;*B;
A = L &gt; 0;
C = abs(B)/2;</code></pre>
<p>The following table summarizes the language that we will use everywhere.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(n\)</span></td>
<td style="text-align: left;">number of vertices in the graph</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(m\)</span></td>
<td style="text-align: left;">number of edges in the graph</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(u\in\mathbf{R}^n\)</span></td>
<td style="text-align: left;">scalar field <span class="math inline">\(u\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\mathbf{v}\in\mathbf{R}^m\)</span></td>
<td style="text-align: left;">scalar field <span class="math inline">\(\mathbf{v}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(B:\mathbf{R}^n\to\mathbf{R}^m\)</span></td>
<td style="text-align: left;">gradient</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(-B^T:\mathbf{R}^m\to\mathbf{R}^n\)</span></td>
<td style="text-align: left;">divergence</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(L:\mathbf{R}^n\to\mathbf{R}^n\)</span></td>
<td style="text-align: left;">Laplacian</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(C:\mathbf{R}^n\to\mathbf{R}^m\)</span></td>
<td style="text-align: left;">centering operator (from vertices to edges)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(C^T:\mathbf{R}^m\to\mathbf{R}^n\)</span></td>
<td style="text-align: left;">centering operator (from edges to vertices)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(C^TC:\mathbf{R}^n\to\mathbf{R}^n\)</span></td>
<td style="text-align: left;">smoothing operator</td>
</tr>
</tbody>
</table>
<p>The most important notion is that the matrix <span class="math inline">\(B\)</span> is called the <span> <strong>gradient</strong></span>. It is a linear operator that maps scalar fields (vectors of lenght <span class="math inline">\(n\)</span>) into vector fields (vectors of length <span class="math inline">\(m\)</span>). This definition is used for an arbitrary graph, but it makes a lot of sense when the graph is the grid of an image, because in that case the gradient corresponds exactly to the gradient computed using finite differences.</p>
<h2 id="the-graph-associated-to-an-image"><span class="header-section-number">3</span> The graph associated to an image</h2>
<p>The pixels of an image are arranged naturally in the shape of a grid. Here, for example, you have the grid of a <span class="math inline">\(4\times 3\)</span> image:</p>
<p><img src="gridgraph.png" alt="image" /></p>
<p>Here you see that the graph has <span class="math inline">\(n=12\)</span> vertices and <span class="math inline">\(m=17\)</span> edges. In general, for an image of size <span class="math inline">\(w\times h\)</span>, the graph will have <span class="math inline">\(n=wh\)</span> vertices and <span class="math inline">\(m=(w-1)h+(h-1)w\)</span> edges. The matrix <span class="math inline">\(A\)</span> of such a graph is build by the following octave code</p>
<pre><code>function A = grid_graph(w, h)                       # build a grid graph WxH
        px = sparse(1:w-1, 2:w, 1, w, w);           # path graph of length W
        py = sparse(1:h-1, 2:h, 1, h, h);           # path graph of length H
        U = kron(py,speye(w)) + kron(speye(h),px);  # kronecker sum
        A = U + U&#39;;                                 # symmetrization
end</code></pre>
<p>This works because the grid graph is the product graph of two paths, and the adjacency matrix of a product graph is the Kronecker sum of their matrices.</p>
<p>The graph defines just the <em>domain</em> of an image. We still need the <em>data</em>. As a sample image, we will use the amazing portrait of Samuel Beckett by Jane Bown:</p>
<p><img src="i/beckett.png" alt="image" /> <span><code>beckett.png</code></span></p>
<p>The easiest operator to understand is the Laplacian. The following octave code thus reads an image, applies the laplacian operator, and saves the result.</p>
<pre><code>x = imread(&quot;i/beckett.png&quot;);        # load input image
[w, h] = size(x);                 # extract dimensions
x = double(x(:));                 # flatten image data into a vector
A = grid_graph(w,h);              # build graph adjacency matrix
L = A - diag(sum(A));             # Laplacian matrix
y = L * x;                        # Laplacian of the original image
z = uint8(reshape(127-2*y,w,h));  # contrast change and reshape
imwrite(z, &quot;beckett_lap.png&quot;);    # save output image</code></pre>
<p><img src="beckett_lap.png" alt="image" /> <span><code>beckett_lap.png</code></span></p>
<p>The typical color coding for looking at a laplacian is such that gray=zero, white=negative, black=positive. As expected, the laplacian enhances the edges and textures while setting the constant regions to zero.</p>
<p>By substracting the laplacian to the image, we “sharpen” the original image.</p>
<pre><code>y = x - L * x;                                        # image minus laplacian
imwrite(reshape(uint8(y),w,h), &quot;beckett_sharp.png&quot;);  # save output image</code></pre>
<p><img src="beckett_sharp.png" alt="image" /> <span><code>beckett_sharp.png</code></span></p>
<p>Conversely, we can smooth the image by adding multiples of the laplacian to it, iteratively. This amounts to approximation the solution of the heat equation on the graph:</p>
<pre><code>S = speye(w*h) + L/4;                                  # smoothing operator
y = S^8 * x;                                           # run 8 smoothing steps
imwrite(reshape(uint8(y),w,h), &quot;beckett_smooth.png&quot;);  # save output image</code></pre>
<p><img src="beckett_smooth.png" alt="image" /> <span><code>beckett_smooth.png</code></span></p>
<h2 id="graph-based-mathematical-morphology"><span class="header-section-number">4</span> Graph-based mathematical morphology</h2>
<p>The morphological operations of <span><strong>dilation</strong></span> and <span><strong>erosion</strong></span> are defined for functions over graphs, as the maximum and minimum value of neighboring vertices. The other morphological operations are all defined in terms of dilation and erosion:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(u\)</span></td>
<td style="text-align: left;">function defined on the vertices of the graph</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(d(u)\)</span></td>
<td style="text-align: left;">dilation (max value among neighboring vertices)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(e(u)\)</span></td>
<td style="text-align: left;">erosion (min value among neighboring vertices)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(d(e(u))\)</span></td>
<td style="text-align: left;">opening</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(e(d(u))\)</span></td>
<td style="text-align: left;">closing</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(d(u) - u\)</span></td>
<td style="text-align: left;">inner morphological gradient</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(u - e(u)\)</span></td>
<td style="text-align: left;">outer morphological gradient</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\frac{1}{2}(d(u) - e(u))\)</span></td>
<td style="text-align: left;">centered morphological gradient</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(d(u) + e(u) - 2u\)</span></td>
<td style="text-align: left;">morphological laplacian</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(u - d(u) - e(u)\)</span></td>
<td style="text-align: left;">morphological sharpening (image minus laplacian)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(u - d(e(u))\)</span></td>
<td style="text-align: left;">top hat (image minus opening)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(e(d(u)) -u\)</span></td>
<td style="text-align: left;">bottom hat (closing minus image)</td>
</tr>
</tbody>
</table>
<p>Due to the inequalities <span class="math inline">\(e(u)\le u\le d(u)\)</span>, we can see that all these operations (except the laplacian) produce positive images. The morphological gradients are also called upwind and downwind derivatives.</p>
<p>Thanks to sparse matrices, the implementation of these operations is very easy. The crucial matrix here is the structuring element matrix <span class="math inline">\(E\)</span>, defined as the adjacency matrix plus the identity. The implementation of the dilation operator is thus</p>
<pre><code>function y = dilation(E, x)
        y = full(max(diag(x)*E))&#39;;    # maximum value along sparse rows
end</code></pre>
<p>Notice that this only works for positive-valued images (otherwise the &quot;max&quot; is perturbed by the zeros in the sparse matrix, which are not ignored). The implementation of the erosion works by computing the dilation of an image in the negative:</p>
<pre><code>function y = erosion(E, x)
        m = 1 + max(x);
        t = m - x;
        y = m - dilation(E, t);
end</code></pre>
<p>And the implementation of all the operations consists simply in copying the table above:</p>
<pre><code>function y = opening(E,x)      y = dilation(E,erosion(E,x));              end
function y = closing(E,x)      y = erosion(E,dilation(E,x));              end
function y = egradient(E,x)    y = x - erosion(E,x);                      end
function y = igradient(E,x)    y = dilation(E,x) - x;                     end
function y = cgradient(E,x)    y = (dilation(E,x) - erosion(E,x)) / 2;    end
function y = mlaplacian(E,x)   y = dilation(E,x) + erosion(E,x) - 2*x;    end
function y = msharpen(E,x)     y = x - mlaplacian(E,x);                   end
function y = tophat(E,x)       y = x - opening(E,x);                      end
function y = bothat(E,x)       y = closing(E,x) - x;                      end</code></pre>
<p>The following code tests all these operations:</p>
<pre><code>x = imread(&quot;i/beckett.png&quot;);
[w,h] = size(x);
x = double(x(:));
A = grid_graph(w,h);
E = A + speye(w*h);            # structuring element

imwrite(uint8(reshape( dilation(E,x)         ,w,h)), &quot;beckett_dil.png&quot;);
imwrite(uint8(reshape( erosion(E,x)          ,w,h)), &quot;beckett_ero.png&quot;);
imwrite(uint8(reshape( opening(E,x)          ,w,h)), &quot;beckett_ope.png&quot;);
imwrite(uint8(reshape( closing(E,x)          ,w,h)), &quot;beckett_clo.png&quot;);
imwrite(uint8(reshape( 2*igradient(E,x)      ,w,h)), &quot;beckett_igrad.png&quot;);
imwrite(uint8(reshape( 2*egradient(E,x)      ,w,h)), &quot;beckett_egrad.png&quot;);
imwrite(uint8(reshape( 2*cgradient(E,x)      ,w,h)), &quot;beckett_cgrad.png&quot;);
imwrite(uint8(reshape( 127-2*mlaplacian(E,x) ,w,h)), &quot;beckett_mlap.png&quot;);
imwrite(uint8(reshape( msharpen(E,x)         ,w,h)), &quot;beckett_msharp.png&quot;);
imwrite(uint8(reshape( 6*tophat(E,x)         ,w,h)), &quot;beckett_top.png&quot;);
imwrite(uint8(reshape( 255-6*bothat(E,x)     ,w,h)), &quot;beckett_bot.png&quot;);</code></pre>
<p><img src="beckett_dil.png" alt="image" /><span><code>beckett_dil.png</code></span><br />
<img src="beckett_ero.png" alt="image" /><span><code>beckett_ero.png</code></span><br />
<img src="beckett_ope.png" alt="image" /><span><code>beckett_ope.png</code></span><br />
<img src="beckett_clo.png" alt="image" /><span><code>beckett_clo.png</code></span><br />
<img src="beckett_igrad.png" alt="image" /><span><code>beckett_igrad.png</code></span><br />
<img src="beckett_egrad.png" alt="image" /><span><code>beckett_egrad.png</code></span><br />
<img src="beckett_cgrad.png" alt="image" /><span><code>beckett_cgrad.png</code></span><br />
<img src="beckett_mlap.png" alt="image" /><span><code>beckett_mlap.png</code></span><br />
<img src="beckett_msharp.png" alt="image" /><span><code>beckett_msharp.png</code></span><br />
<img src="beckett_top.png" alt="image" /><span><code>beckett_top.png</code></span><br />
<img src="beckett_bot.png" alt="image" /><span><code>beckett_bot.png</code></span><br />
It is an interesting exercise to look at these images and try to describe the changes verbally. For example: <span><strong>dilation</strong></span> enlarges the light objects, while <span><strong>erosion</strong></span> enlarges the dark ones. The <span><strong>opening</strong></span> removes the small bright spots and ridges, while <span><strong>closing</strong></span> removes the small dark spots and valleys. All the three <span><strong>gradients</strong></span> look like the euclidean norm of the linear gradient. The <span><strong>inner</strong></span> and <span><strong>outer</strong></span> gradients are very sharp, but are not centered, each one biased towards the dark or the light side of the discontinuities. The <span><strong>centered</strong></span> gradient is the average of the two, which is centered but less sharp. The <span><strong>morphological laplacian</strong></span> is the difference of the inner and outer gradients; it looks almost exactly like the linear laplacian despite being a combination of nonlinear operations. The <span><strong>morphological sharpening</strong></span> is similar to the linear one, based on the reverse heat equation. The <span><strong>top-hat</strong></span> keeps only the britght spots and ridges (those that were removed by the opening), and set to zero the rest of the image. The <span><strong>bottom-hat</strong></span> keeps only the dark spots and valleys (those that were removed by the closing), and sets to zero the rest of the image; thus the bottom-hat produces an image in the negative, that must be negated to visualize it correctly.</p>

<p>As a final comment on graph-based morphology, if you want to do <span> <strong>morphology on binary images</strong></span>, the implementation can be much simpler. For example, the dilation of a mask <span class="math inline">\(m\)</span> can be computed simply by multiplying by powers of the adjacency matrix:</p>
<pre><code>x = imread(&quot;i/beckett.png&quot;);                             # load image
[w,h] = size(x);                                         # extract dimensions
m = double(x(:) &gt; 66);                                   # flatten and binarize

A = grid_graph(w,h) + speye(w*h);                        # structuring element
y = A^6 * m;                                             # apply 6 dilations
y1 = y &gt; 0;                                              # dilation
y2 = !(y &lt; max(y));                                      # erosion

f = 255 / max(y);                                        # gray-scale factor
imwrite(logical(reshape(m,w,h)), &quot;beckett_bin.png&quot;);     # save binary mask
imwrite(uint8(reshape(y,w,h)*f), &quot;beckett_a6.png&quot;);      # save gray-scale
imwrite(logical(reshape(y1,w,h)), &quot;beckett_a6_t0.png&quot;);  # save dilated mask
imwrite(logical(reshape(y2,w,h)), &quot;beckett_a6_tm.png&quot;);  # save dilated mask</code></pre>
<p><img src="beckett_bin.png" alt="image" /><span><code>beckett_bin.png</code></span><br />
<img src="beckett_a6.png" alt="image" /><span><code>beckett_a6.png</code></span><br />
<img src="beckett_a6_t0.png" alt="image" /><span><code>beckett_a6_t0.png</code></span><br />
<img src="beckett_a6_tm.png" alt="image" /><span><code>beckett_a6_tm.png</code></span><br />
</p>
<h2 id="linear-pde-on-graphs"><span class="header-section-number">5</span> Linear PDE on graphs</h2>
<p>(section in preparation)</p>
<h3 id="linear-second-order-equations"><span class="header-section-number">5.1</span> Linear second-order equations</h3>
<h3 id="linear-first-order-equations"><span class="header-section-number">5.2</span> Linear first-order equations</h3>
</body>
</html>
