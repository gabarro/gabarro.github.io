<!doctype html>
<meta charset="utf-8" />
<title>The standard PDE on a manifold</title>
<style type="text/css">
	body { max-width:90ex; }
	pre { background:lightgray; width:80ch; }
	.thm em i { font-style: normal;}
</style>
<script type="text/x-mathjax-config">
	MathJax.Hub.Config({
		tex2jax: {
			inlineMath: [ ['$','$'], ['\\(','\\)'] ],
			processEscapes: true
		}
	});
</script>
<script type="text/javascript" async src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS_CHTML-full">
</script>

<!--
	This file is a literate program.
	The experiments are run by applying the following filter:

		grep ^%SCRIPT | sed 's/&amp;/\&/g' | cut -c9- | sh
-->


<h1>The standard PDE on a manifold</h1>

<p>
We state and solve the standard second-order linear PDE on a compact
Riemannian manifold: the potential, diffusion, diffraction and wave
equations.
$\newcommand{\R}{\mathbf{R}}$
$\newcommand{\Z}{\mathbf{Z}}$

<h2>1. The Laplace-Beltrami spectrum</h2>

<p>
Let $M$ be a compact Riemannian manifold (with or without boundary), and
let $\Delta$ be its Laplace-Beltrami operator, defined
as $\Delta=*d*d$, where $d$ is the exterior derivative (which is independent
of the metric) and $*$ is the Hodge duality between $p$-forms
and $d-p$-forms (which is defined using the metric).

<p>
The following are standard results in differential geometry (see e.g.
Warner's book chapter
6 <a href="https://link.springer.com/content/pdf/10.1007\%2F978-1-4757-1799-0_6.pdf">https://link.springer.com/content/pdf/10.1007\%2F978-1-4757-1799-0_6.pdf</a>)

<ul>
	<li style='list-style-type:none'>(1) There is a sequence of $\mathcal{C}^\infty(M)$
		functions $\varphi_n$ and positive
		numbers $\lambda_n\to\infty$ such that
		$$\Delta\varphi_n=-\lambda_n\varphi_n$$
	<li style='list-style-type:none'>(2) The functions $\varphi_n$, suitably normalized, are an
		orthonormal basis of $L^2(M)$.
</ul>

<p>
These results generalize Fourier series to an arbitrary smooth manifold $M$.
Any square-integrable function $f:M\to\R$ is written uniquely as
$$f(x)=\sum_nf_n\varphi_n(x)$$ and the coefficients $f_n$ are computed by
$$f_n=\int_Mf\varphi_n.$$  Some particular cases are the habitual Fourier and
sine bases (but not the cosine basis), bessel functions for the disk, and
spherical harmonics for the surface of a sphere.

<table border="1" cellspacing="0" cellpadding="7">
<tr><td>

	<td>$M$ <td> $\varphi_n$ <td> $-\lambda_n$ <tr><td>
	
	interval <td> $[0,2\pi]$ <td> $\sin\left(\frac{nx}{2}\right)$ <td> $n^2/4$ <tr><td>
	circle <td> $S^1$ <td> $\sin(n\theta),\cos(n\theta)$ <td> $n^2$ <tr><td>
	square <td> $[0,2\pi]^2$ <td>
	$\sin\left(\frac{nx}{2}\right)\sin\left(\frac{m\theta}{2}\right)$ <td>
	$\frac{n^2+m^2}{4}$ <tr><td>
	torus <td> $(S^1)^2$ <td> $\sin(nx)\sin(my),\ldots$ <td> $n^2+m^2$ <tr><td>
	disk <td> $|r|\le1$ <td> $\sin,\cos(n\theta)J_n(\rho_{m,n}r)$ <td>
	$\rho_{m,n}$ roots of $J_n$ <tr><td>
	sphere <td> $S^2$ <td> $Y^m_l(\theta,\varphi)$ <td> $l^2+l$
</table>

<p>
The eigenfunctions $\varphi_n$ are called the vibration modes of $M$, and the
eigenvalues $\lambda_n$ are called the (squared) fundamental frequencies of $M$.

<p>
Several geometric properties of $M$ can be interpreted in terms of the
Laplace-Beltrami spectrum.  For example, if $M$ has $k$ connected components,
the first $k$ eigenfuntions will be supported successively on each connected
component.  On a connected manifold $M$, the first vibration mode can be
taken to be positive $\varphi_1\ge0$, thus all the other modes have
non-constant signs (because they are orthogonal to $\varphi_1$).  In
particular, the sign of $\varphi_2$ cuts $M$ in two parts in an optimal way,
it is the Cheeger cut of $M$, maximizing the perimeter/area ratio of the cut.

<p>
The zeros of $\varphi_n$ are called the nodal curves (or nodal sets) of $M$,
or also the Chladni patterns.  If $M$ is a subdomain of the plane, these
patterns can be found by cutting an object in the shape of $M$, pouring a
layer of sand over it, and letting it vibrate by high-volume sound waves at
different frequencies.  For most frequencies, the sand will not form any
particular pattern, but when the frequency coincides with
a $\sqrt{\lambda_n}$, the sand will accumulate over the set $[\varphi_n=0]$,
which is the set of points of the surface that do not move when the surface
vibrates at this frequency.  In the typical case, the number of connected
components of $[\varphi_n&gt;0]$ grows linearly with $n$, thus the
functions $\varphi_n$ become more oscillating (less regular) as $n$ grows.

<p>
Generally, symmetries of $M$ arise as multiplicities of eigenvalues.
The Laplace-Beltrami spectrum ${\lambda_1,\lambda_2,\lambda_3,\ldots}$ is
closely related, but not identical, to the geodesic length spectrum, that
measures the sequence of lengths of all closed geodesics of $M$.  The grand
old man of this theory is Yves Colin de Verdière, student of Marcel Berger.

<p>
Geometry is not in general a spectral invariant, but non-isometric manifolds
with the same spectrum are difficult to come by.  The first pair of distinct
but isospectral manifolds was wound in 1964 by John Milnor, in dimension 16.
The first example in dimension 2 was found in 1992 by Gordon, Webb and
Wolperd, and it answered negatively the famous question of Marc Kac ``Can you
hear the shape of a drum?'.
In 2018, we have many ways to construct discrete and continuous families of
isospectral manifolds in dimensions two and above.

<h2>2. The standard equations and their explicit solutions</h2>

<p>
The classical linear second order equations (potential, heat, wave and
Schrödinger) are all defined in terms of the Laplacian operator in space.
Thus, they can be defined readily on an arbitrary Riemannian manifold $M$.
If $M$ is compact, the solution can be found explicitly in terms of the
Laplace-Beltrami eigenfunctions.  Henceforth we will call the expression of a
function $f:M\to\R$ as $f=\sum_nf_n\varphi_n$ the Fourier series of $f$, the
numbers $f_n$ the Fourier coefficients of $f$ and so on.

<p>
The simplest case is <b>Poisson equation</b>
$$
	\Delta u = f
$$
The solution is found by expressing $u$ and $f$ as Fourier series and
identifying the coefficients:
$$
u(x) = \sum_n\frac{-f_n}{\lambda_n}\varphi_n(x)
$$
Notice that since $\lambda_n\to\infty$, the Fourier coefficients of $u$ tend
to zero faster than those of $f$, thus $u$ is more regular than $f$
(this is obvious from the equation, since $\Delta u$ is less regular than $u$).

<p>
Another simple case is the <b>screened Poisson equation</b>
$$
\Delta u = \alpha u + f
$$
and the solution is found by the same technique:
$$
u(x) = \sum_n\frac{-f_n}{\alpha+\lambda_n}\varphi_n(x)
$$
This is like the regular Poisson equation, but the regularity is enhanced
by $\alpha$.

<p>
The next case is the <b>heat equation</b>, also called <b>diffusion</b> or <b>smoothing</b> equation:
$$
\begin{cases}
	u_t = \Delta u &amp; (x,t)\in M\times[0,T] \\
	u(x,0)=g(x) &amp; x\in M\\
\end{cases}
$$
This equation requires an initial condition $g$.  The solution is found by
separation of variables, which leads to a trivial ODE, resulting in
$$
u(x,t)=\sum_ng_ne^{-{\lambda_n}t}\varphi_n(x)
$$
It is immediate to check that this expression is a solution of the heat
equation with initial condition $g$.  Several properties of the solution are
visible from this form, most notably that $u(x,\infty)=u_1$ if $\lambda_1=0$,
or $1$ otherwise.  A pure vibration mode $\varphi_n$ decays exponentially to
zero, and the speed of the exponential decay is $\lambda_n$.

<p>
By combining the heat and Poisson equations, we get the <b>heat equation
with source</b>:
$$
\begin{cases}
	u_t = \Delta u + f &amp; (x,t)\in M\times[0,T] \\
	u(x,0)=g(x) &amp; x\in M\\
\end{cases}
$$
whose solution is
$$
u(x,t)=\sum_n\left(
\frac{f_n}{\lambda_n}+g_ne^{-{\lambda_n}t}
\right)\varphi_n(x)
$$

<p>
The solution of the <b>reverse heat equation</b>
$$
\begin{cases}
	u_t = -\Delta u &amp; (x,t)\in M\times[0,T] \\
	u(x,0)=g(x) &amp; x\in M\\
\end{cases}
$$
is formally similar
$$
u(x,t)=\sum_ng_ne^{{\lambda_n}t}\varphi_n(x)
$$
but notice that it blows up, often in a finite time.

<p>
Both direct and reverse heat equations are of the form $u_t=c\Delta u$, whose
solution is $u(x,t)=\sum_n g_n e^{-c\lambda_n t}\varphi_n(x)$.  The
constant $c$ is the speed of transmission of heat.  An intermediate behaviour
between $c&gt;0$ and $c&lt;0$ happens when $c=i$.

<p>
The <b>linear Schrödinger equation</b>, also called <b>diffraction equation</b>
$$
\begin{cases}
	w_t = i\Delta w &amp; (x,t)\in M\times[0,T] \\
	w(x,0)=g(x) &amp; x\in M\\
\end{cases}
$$
describes the evolution of a complex-valued function $w$.  It can be
interpreted as a system of two coupled real equations by writing $w=u+iv$
(here, assuming a real-valued initial condition $g$):
$$
\begin{cases}
	u_t = -\Delta v &amp; (x,t)\in M\times[0,T] \\
	v_t = \Delta u &amp; (x,t)\in M\times[0,T] \\
	u(x,0)=g(x) &amp; x\in M\\
	v(x,0)=0 &amp; x\in M\\
\end{cases}
$$
The solution is then
$$
w(x,t)=\sum_n g_n e^{-i\lambda_n t}\varphi_n(x)
$$
or, in terms of $u$ and $v$:
$$
\begin{cases}
	u(x,t) = \sum_n g_n\cos\left(\lambda_nt\right)\varphi_n(x) \\
	v(x,t) = \sum_n-g_n\sin\left(\lambda_nt\right)\varphi_n(x) \\
\end{cases}
$$
thus, a pure vibration mode $\varphi_n$ oscillates periodically, at a
frequency $\lambda_n$.  In terms of $|w|$, this phenomenon is called
<i>diffraction</i>.

<p>
The <b>wave equation</b> is
$$
\begin{cases}
	u_{tt} = \Delta u &amp; (x,t)\in M\times[0,T] \\
	u(x,0) = g(x) &amp; x\in M \\
	u_t(x,0) = h(x) &amp; x\in M \\
\end{cases}
$$
notice that it requires an initial condition and an initial speed.  By
linearity, we can deal with these separately, and then sum the
results.  The solution is then
$$
	u(x,t)=\sum_n\left(
	g_n\cos\left(\sqrt{\lambda_n} t\right)
	+
	\frac{h_n}{\sqrt{\lambda_n}}\sin\left(\sqrt{\lambda_n} t\right)
	\right)\varphi_n(x)
$$
Thus, a pure vibration mode $\varphi_n$ oscillates with
frequency $\sqrt{\lambda_n}$.

<p>
Finally the <b>wave equation with a force</b> is the most complex case we treat here:
$$
\begin{cases}
	u_{tt} = \Delta u +f&amp; (x,t)\in M\times[0,T] \\
	u(x,0) = g(x) &amp; x\in M \\
	u_t(x,0) = h(x) &amp; x\in M \\
\end{cases}
$$
The solution
$$
	u(x,t)=\sum_n\left(
	\frac{f_n}{\lambda_n}
	+
	g_n\cos\left(\sqrt{\lambda_n} t\right)
	+
	\frac{h_n}{\sqrt{\lambda_n}}\sin\left(\sqrt{\lambda_n} t\right)
	\right)\varphi_n(x)
$$
is found by the same methods as above.

<h2>3. Discretization and implementation in Octave</h2>

<p>
Except in emblematic cases (rectangle, torus, sphere) the eigenfunctions of
an arbitrary manifold $M$ do not have a closed-form expression.

<p>
For practical computations, we are thus restricted to numerical methods in the
discrete case.  The most convenient form for this discretization is to
representd $M$ as a graph with weights in their edges.  In this context, we
have the following objects
<ul>
	<li>The weighted graph $G=(V,E)$ where $V$ is a set of $n$ vertices.
	<li>The Laplacian matrix $L$ of this graph, which is of
		size $n\times n$
	<li>The space $\R^n$ is identified with functions $V\to\R$.
		Thus $\R^n$ is the discrete version of $\mathcal{C}^\infty(M)$.
</ul>
typically $L$ will be a matrix of rank $n-1$ with a constant eigenvector of
eigenvalue 0.

<p>
We can find the eigensystem of $L$ by calling <code>eigs(L)</code> in octave, and
transfer the solutions obtained above using the obtained eigenvectors and
eigenvalues.  However, in most cases the solution is more easily obtained by
solving a linear problem.

<p>
To fix the ideas we start with a concrete example: a square domain with flat
metric.  The following is a complete program that computes the chladni
figures of a square domain.

<pre>
w = 128;                                   # width and height of the domain
p = sparse(1:w-1, 2:w, 1, w, w);           # path graph of length p
A = kron(p, speye(w)) + kron(speye(w), p); # kronecker sum
L = A+A' - diag(sum(A+A'));                # graph laplacian
[f,l] = eigs(L, 64, "sm");                 # eigs of smallest magnitude
</pre>
<!--
%SCRIPT mkdir -p o
%SCRIPT octave <<END
%SCRIPT w = 96;
%SCRIPT p = sparse(1:w-1, 2:w, 1, w, w);
%SCRIPT A = kron(p, speye(w)) + kron(speye(w), p);
%SCRIPT L = A+A' - diag(sum(A+A'));
%SCRIPT [f,l] = eigs(-L'*L, 64, "sm");
%SCRIPT for i=1:64
%SCRIPT         n = sprintf("o/chladni_
%SCRIPT         x = uint8(reshape(200*double(0<f(:,i)),w,w));
%SCRIPT         imwrite(x, n);
%SCRIPT endfor
%SCRIPT END
-->

<p>
After running this code, the ith eigenfunction is <code>f(:,i)</code> and the
eigenvalues are on <code>diag(l)</code>.

<p>
<img src="o/chladni_001.png">
<img src="o/chladni_002.png">
<img src="o/chladni_003.png">
<img src="o/chladni_004.png">
<img src="o/chladni_005.png">
<img src="o/chladni_006.png">
<img src="o/chladni_007.png">
<img src="o/chladni_008.png">

<p>
<img src="o/chladni_009.png">
<img src="o/chladni_010.png">
<img src="o/chladni_011.png">
<img src="o/chladni_012.png">
<img src="o/chladni_013.png">
<img src="o/chladni_014.png">
<img src="o/chladni_015.png">
<img src="o/chladni_016.png">

<p>
<img src="o/chladni_017.png">
<img src="o/chladni_018.png">
<img src="o/chladni_019.png">
<img src="o/chladni_020.png">
<img src="o/chladni_021.png">
<img src="o/chladni_022.png">
<img src="o/chladni_023.png">
<img src="o/chladni_024.png">

<p>
<img src="o/chladni_025.png">
<img src="o/chladni_026.png">
<img src="o/chladni_027.png">
<img src="o/chladni_028.png">
<img src="o/chladni_029.png">
<img src="o/chladni_030.png">
<img src="o/chladni_031.png">
<img src="o/chladni_032.png">

<p>
<img src="o/chladni_033.png">
<img src="o/chladni_034.png">
<img src="o/chladni_035.png">
<img src="o/chladni_036.png">
<img src="o/chladni_037.png">
<img src="o/chladni_038.png">
<img src="o/chladni_039.png">
<img src="o/chladni_040.png">

<p>
<img src="o/chladni_041.png">
<img src="o/chladni_042.png">
<img src="o/chladni_043.png">
<img src="o/chladni_044.png">
<img src="o/chladni_045.png">
<img src="o/chladni_046.png">
<img src="o/chladni_047.png">
<img src="o/chladni_048.png">

<p>
<img src="o/chladni_049.png">
<img src="o/chladni_050.png">
<img src="o/chladni_051.png">
<img src="o/chladni_052.png">
<img src="o/chladni_053.png">
<img src="o/chladni_054.png">
<img src="o/chladni_055.png">
<img src="o/chladni_056.png">

<p>
<img src="o/chladni_057.png">
<img src="o/chladni_058.png">
<img src="o/chladni_059.png">
<img src="o/chladni_060.png">
<img src="o/chladni_061.png">
<img src="o/chladni_062.png">
<img src="o/chladni_063.png">
<img src="o/chladni_064.png">

<p>
And now, with Dirichlet boundary conditions (slightly different code)

<pre>
w = 128;                                    # width and height of the domain
p = sparse(1:w-1, 2:w, 1, w, w) - speye(w); # path graph of length p
A = kron(p, speye(w)) + kron(speye(w), p);  # kronecker sum
L = A + A';                                 # graph laplacian
[f,l] = eigs(L, 64, "sm");                  # eigs of smallest magnitude
</pre>
<!--
%SCRIPT octave <<END
%SCRIPT w = 96;
%SCRIPT p = sparse(1:w-1, 2:w, 1, w, w) - speye(w);
%SCRIPT A = kron(p, speye(w)) + kron(speye(w), p);
%SCRIPT L = A + A';
%SCRIPT [f,l] = eigs(-L'*L, 64, "sm");
%SCRIPT for i=1:64
%SCRIPT         n = sprintf("o/dchladni_
%SCRIPT         x = uint8(reshape(200*double(0<f(:,i)),w,w));
%SCRIPT         imwrite(x, n);
%SCRIPT endfor
%SCRIPT END
-->

<p>
<img src="o/dchladni_001.png">
<img src="o/dchladni_002.png">
<img src="o/dchladni_003.png">
<img src="o/dchladni_004.png">
<img src="o/dchladni_005.png">
<img src="o/dchladni_006.png">
<img src="o/dchladni_007.png">
<img src="o/dchladni_008.png">

<p>
<img src="o/dchladni_009.png">
<img src="o/dchladni_010.png">
<img src="o/dchladni_011.png">
<img src="o/dchladni_012.png">
<img src="o/dchladni_013.png">
<img src="o/dchladni_014.png">
<img src="o/dchladni_015.png">
<img src="o/dchladni_016.png">

<p>
<img src="o/dchladni_017.png">
<img src="o/dchladni_018.png">
<img src="o/dchladni_019.png">
<img src="o/dchladni_020.png">
<img src="o/dchladni_021.png">
<img src="o/dchladni_022.png">
<img src="o/dchladni_023.png">
<img src="o/dchladni_024.png">

<p>
<img src="o/dchladni_025.png">
<img src="o/dchladni_026.png">
<img src="o/dchladni_027.png">
<img src="o/dchladni_028.png">
<img src="o/dchladni_029.png">
<img src="o/dchladni_030.png">
<img src="o/dchladni_031.png">
<img src="o/dchladni_032.png">

<p>
<img src="o/dchladni_033.png">
<img src="o/dchladni_034.png">
<img src="o/dchladni_035.png">
<img src="o/dchladni_036.png">
<img src="o/dchladni_037.png">
<img src="o/dchladni_038.png">
<img src="o/dchladni_039.png">
<img src="o/dchladni_040.png">

<p>
<img src="o/dchladni_041.png">
<img src="o/dchladni_042.png">
<img src="o/dchladni_043.png">
<img src="o/dchladni_044.png">
<img src="o/dchladni_045.png">
<img src="o/dchladni_046.png">
<img src="o/dchladni_047.png">
<img src="o/dchladni_048.png">

<p>
<img src="o/dchladni_049.png">
<img src="o/dchladni_050.png">
<img src="o/dchladni_051.png">
<img src="o/dchladni_052.png">
<img src="o/dchladni_053.png">
<img src="o/dchladni_054.png">
<img src="o/dchladni_055.png">
<img src="o/dchladni_056.png">

<p>
<img src="o/dchladni_057.png">
<img src="o/dchladni_058.png">
<img src="o/dchladni_059.png">
<img src="o/dchladni_060.png">
<img src="o/dchladni_061.png">
<img src="o/dchladni_062.png">
<img src="o/dchladni_063.png">
<img src="o/dchladni_064.png">

<p>
For completenes, this is the octave code that saves the figures above
<pre>
for i=1:64
        n = sprintf("o/chladni_
        x = reshape(200*double(0&lt;f(:,i)),w,w);
        iio_write(n, x);
endfor
</pre>


<hr>


<!-- yes i know, wanna fight about it ? -->
<img src="http://boucantrin.ovh.hw.ipol.im:7743/white_pixel.png?a=The_standard_PDE_on_a_manifold" width="1" height="1">

